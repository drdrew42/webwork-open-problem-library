########################################################################

DOCUMENT();      

loadMacros(
   "PGstandard.pl",     # Standard macros for PG language
   "MathObjects.pl",
   "PGML.pl",
   "PGgraphmacros.pl",
   "answerHints.pl"
);

# Print problem number and point value (weight) for the problem
TEXT(beginproblem());

# Show which answers are correct and which ones are incorrect
$showPartialCorrectAnswers = 1;

##############################################################
#
#  Setup
#
#
Context("Numeric");

##############################################
#  Begin trig functions in degrees

Context()->functions->remove(
  qw(sin cos tan sec csc cot acos asin atan asec acsc acot)
);

package NewFunc;
our @ISA = qw(Parser::Function::numeric);

sub cos {
  shift; my $x = shift;
  return CORE::cos($x*3.14159265358979/180);
}

sub sin {
  shift; my $x = shift;
  return CORE::sin($x*3.14159265358979/180);
}

sub tan {
  shift; my $x = shift;
  return CORE::sin($x*3.14159265358979/180)/CORE::cos($x*3.14159265358979/180);
}

sub sec {
  shift; my $x = shift;
  return 1.0/CORE::cos($x*3.14159265358979/180);
}

sub csc {
  shift; my $x = shift;
  return 1.0/CORE::sin($x*3.14159265358979/180);
}

sub cot {
  shift; my $x = shift;
  return CORE::cos($x*3.14159265358979/180)/CORE::sin($x*3.14159265358979/180);
}

sub acos {CORE::atan2(CORE::sqrt(1-$_[1]*$_[1]),$_[1])*180/3.14159265358979}
sub asin {CORE::atan2($_[1],CORE::sqrt(1-$_[1]*$_[1]))*180/3.14159265358979}
sub atan {CORE::atan2($_[1],1)*180/3.14159265358979}
sub asec {CORE::atan2($_[1],CORE::sqrt(1-$_[1]*$_[1]))*180/3.14159265358979}
sub acsc {CORE::atan2(CORE::sqrt(1-$_[1]*$_[1]),$_[1])*180/3.14159265358979}
sub acot {CORE::atan2(1,$_[1])*180/3.14159265358979}

# done declaring NewFunc::trig functions
package main;

# Make new functions work on formulas as well as numbers
sub cos($) {Parser::Function->call('cos',@_)} 
sub sin($) {Parser::Function->call('sin',@_)} 
sub tan {Parser::Function->call('tan',@_)}
sub sec {Parser::Function->call('sec',@_)} 
sub csc {Parser::Function->call('csc',@_)} 
sub cot {Parser::Function->call('cot',@_)}
sub acos {Parser::Function->call('acos',@_)}
sub asin {Parser::Function->call('asin',@_)}
sub atan {Parser::Function->call('atan',@_)}
sub asec {Parser::Function->call('asec',@_)}
sub acsc {Parser::Function->call('acsc',@_)}
sub acot {Parser::Function->call('acot',@_)}

#  Add the new functions to the Context
Context()->functions->add( 
  cos => {class => 'NewFunc', TeX => '\cos'}, 
  sin => {class => 'NewFunc', TeX => '\sin'},
  tan => {class => 'NewFunc', TeX => '\tan'},
  sec => {class => 'NewFunc', TeX => '\sec'},
  csc => {class => 'NewFunc', TeX => '\csc'},
  cot => {class => 'NewFunc', TeX => '\cot'},
  acos => {class => 'NewFunc', TeX => '\arccos'},
  asin => {class => 'NewFunc', TeX => '\arcsin'},
  atan => {class => 'NewFunc', TeX => '\arctan'},
  asec => {class => 'NewFunc', TeX => '\arcsec'},
  acsc => {class => 'NewFunc', TeX => '\arccsc'},
  acot => {class => 'NewFunc', TeX => '\arccot'},
);

#  End trig functions in degrees
###################################################

Context()->flags->set(
  reduceConstants=>0, 
  reduceConstantFunctions=>0,
  tolType=>'absolute',
  tolerance=>0.0005
);

$angMin = 15;
$angMax = 39;

$B = random(15,39,2);
$C = 90 - $B;

$BC = random(5,19,1);
$AC = Formula("$BC*sin($B)");
$AB = Formula("$BC*cos($B)");

$ABrad = Real("$BC*cos($B*pi/180)");
$BCrad = Real("$BC*sin($B*pi/180)");

$max = max($AB,$AC);

$xmin = 0;
$ymin = 0;
$xmax = Real("$AB/$max");
$ymax = Real("$AC/$max");
$bufX = (1.3 - $xmax)/2;
$bufY = (1.3 - $ymax)/2;
$xAngPos = -0.15/($angMax-$angMin)*($B-$angMin)+0.3;
$yAngPos = 0.04/($angMax-$angMin)*($B-$angMin)+0.06;

$angleB = "$B~~x{00B0}";
$angleC = "$C~~x{00B0}";

# Problem Graph #
###############

$gr = init_graph(-$bufX,-$bufY,$xmax+$bufX,$ymax+$bufY,size=>[300,300]);
$gr->lb('reset');
$gr->lb( new Label($xmin,$ymin,'A','black','center','top'));
$gr->lb( new Label($xmax,$ymin,'B','black','center','top'));
$gr->lb( new Label($xmin,$ymax,'C','black','center','bottom'));

$gr->lb( new Label($xmax-$xAngPos,$ymin+0.05,"$angleB",'blue','center','middle')); 
# $gr->lb( new Label($xmin+0.057,$ymax-$yAngPos,"$angleC",'blue','center','middle')); 

# $gr->lb( new Label($xmax/2,$ymin-0.025,"$AB",'blue','center','middle'));
# $gr->lb( new Label($xmin-0.04,$ymax/2,"$AC",'blue','center','middle'));
$gr->lb( new Label($xmax/2 +0.05, $ymax/2+0.05,"$BC",'blue','center','middle'));


$gr->moveTo($xmin+0.1,$ymin);
$gr->lineTo($xmin+0.1,$ymin+0.1,"red",2); # right angle
$gr->lineTo($xmin,$ymin+0.1,"red",2); # right angle
$gr->moveTo($xmin,$ymin);
$gr->lineTo($xmax,$ymin,"black",2); # bottom edge (AB)
$gr->lineTo($xmin,$ymax,"black",2); # hypotenuse (BC)
$gr->lineTo($xmin,$ymin,"black",2); # left edge (AC)

##############################################################
#
#  Text
#
#

BEGIN_PGML

>> [@ image(insertGraph($gr), width=>400, height=>400, tex_size=>800, extra_html_tags=>'alt="Right triangle ABC with right angle A." ' ) @]* <<

If angle B measures [` [$B]^{\circ} `] and [` \overline{BC} `] has length [$BC], find:

* Angle C (in degrees): [__________]
* The length of [` \overline{AB} `]: [__________]
* The length of [` \overline{AC} `]: [__________]

If you use a calculator to find a decimal approximation, your answer must be accurate to at least 3 decimal places.  
(Just be sure that your calculator is set to **degrees**, **not radians**.)

You are also allowed to use the sine, cosine and tangent functions in your answer instead of using a calculator.

END_PGML

ANS(Real($C)->cmp);
ANS($AB->cmp()->withPostFilter(AnswerHints( 
  $ABrad => "Make sure your calculator is set to 'degrees'.",
  $AC => "Are you sure you're using the right trigonometric function for your angle?"
)));
ANS($AC->cmp()->withPostFilter(AnswerHints( 
  $ACrad => "Make sure your calculator is set to 'degrees'.",
  $AB => "How can the hypotenuse be shorter than the given leg?"
)));

ENDDOCUMENT();        
